/*
@file: graph.cpp
@brief: definition of functions in graph class
@author: Shengkun Wu
@data: 2021/7/26

@Explanation of algorithm: 
This algorithm is not the A* algorithm. Because I can not prove that the path found by \
  the A* algorithm is the best one, I tried anothor strategy. 
This algorithm is not the Dijkstra algorithm, either. 
The complexity of the Dijkstra algorithm is O(n^2), So I didn't use it.
My strategy is to find the distance generation by generation.

Step1:definition of around vector of each point.
The around vector of a point consists of points which are white \
    and can jump to the point by one step.

Step2: definition of generations.
The first generation consists of the start point.
The nth generation consists of points which are in the around vector of \
    a point in the (n-1)th generation and not in previous generations.

Step3: assign distance to each points:
1: the distance of start point with start point is ofcouse 0.
2: Suppose we have assigned the distance for each points in the (n-1)th generation.
Next, we need to compute the distance of each point in the nth generation. 
To make the distance small enough, we start from the points which are connected to \
    the point with the minimum distance in the (n-1)th generation.

Step4: search path reversly.
We begin with the end point. We consider the around vector of the end point and \
    choose the point which has the minimum distance in the around vector. 
Let this point be the new end point. 
After that we begin with the new end point and consider it around vector.
We continue to do this procejure untail we find the start point.
There is one special case. Note that the initialization of distance is -1.
If the distance of the end point is -1, it means that it hasn't been reached. 
In this case the path is set to be empty.
*/
#include "graph.h"


/*
@fn: constructor of Graph
@brief: generation of a graph through a matrix M
@param[in]; M has to be a matrix;
@details: nodes in the graph generated by this function haven't arround tabel. So we have to
set around tabel by another function.
*/
Graph::Graph(const std::vector<std::vector<int> > M){
    _xmax=static_cast<int> (M.size()); 
    _ymax=static_cast<int> (M[0].size());
    for (int i = 0; i < _xmax; ++i){
        std::vector<Node*> tmp;
        for(int j=0; j<_ymax;++j){
            Node *tn=new Node();
            tn->_x=i; 
            tn->_y=j;
            if(M[i][j]==0){
                tn->_color=kWhite;
            }
            if(M[i][j]==1){
                tn->_color=kBlack;
            }
            tmp.push_back(tn);
        }
        _nodes.push_back(tmp);
    }
}

/*details:return true only if c1 and c2 are both in the graph and can jump to each other.
*/
bool Graph::checkJump(Coordinate c1, Coordinate c2){
    if(!c1.checkIn(_xmax,_ymax)){
        return false;
    }
    if(!c2.checkIn(_xmax,_ymax)){
        return false;
    }
    if(_nodes[c1._x][c1._y]->_color==kBlack || _nodes[c2._x][c2._y]->_color==kBlack){
        return false;
    }
    if(c1.connectDist(c2)==0){ 
        return false;
    }
    if(c1.connectDist(c2)==10){
        return true;
    }
    if(_nodes[c1._x][c2._y]->_color==kWhite){
        return true;
    }
    if(_nodes[c2._x][c1._y]->_color==kWhite){
        return true;
    }
    return false;
}

/*
@param[in]; M has to be a matrix;
@details: When the size of this graph isn't the same as the size of M, don't do any thing. 
    Otherwise, generalize the around tabel of each node.
*/
void Graph::genArround(const std::vector<std::vector<int>> M){
    for(int i=0; i<_xmax;++i){
        for (int j=0; j < _ymax; ++j){
            for(int k=i-1;k<=i+1;++k){
                for(int l=j-1;l<=j+1;++l){
                    Coordinate c1(i,j);
                    Coordinate c2(k,l);
                    if(checkJump(c1,c2)){
                        _nodes[i][j]->_around.push_back(c2);
                    }
                }
            }
        }
    }
}


Graph::~Graph(){
    for(int i=0;i<_nodes.size();++i){
        for(int j=0; j<_ymax;++j){
            delete this->_nodes[i][j];
        }
    }
}



bool Graph::assignDist(Coordinate c, int dist){
    if(c.checkIn(_xmax,_ymax)){
        _nodes[c._x][c._y]->_dist=dist;
        return true;
    }
    return false;
}


void Graph::setGen(Coordinate c, int n){
    _nodes[c._x][c._y]->_gen=n;
}

/*
@para[in]: tt is a vector of table and represent the present generation.
@details:find next generation of tt. and set the number _gen to the _gen of tt[0] plus 1.
*/
std::vector<Coordinate> Graph::findNext(std::vector<Coordinate> tt){
    std::vector<Coordinate> nt={};
    if(tt.size()==0){
        return nt;
    }
    else{
        for(int i=0;i<tt.size();++i){
            int x=tt[i]._x;
            int y=tt[i]._y;
            std::vector<Coordinate> vc=_nodes[x][y]->_around;
            for(int j=0;j<vc.size();++j){
                if(getGen(vc[j])==-1){
                    nt.push_back(vc[j]);
                    int n=getGen(tt[0])+1;
                    setGen(vc[j],n);
                }
            }
        }
        return nt;
    }
}

/*
@details;Get a point  which have the minimal distance in a vector of Coordinate 
    and its distance is not -1. If no such point return the fisrt point in the vector.
*/
Coordinate Graph::minDist(std::vector<Coordinate> tt){
    if(tt.size()!=0){
        Coordinate c(tt[0]._x,tt[0]._y);
        for(int i=1;i<tt.size();++i){
            int d1=getDist(c);
            int d2=getDist(tt[i]);
            if(d1==-1&& d2!=-1){
                c=tt[i];
            }
            else if(d1!=-1 && d2!=-1 && d2<d1){
                c=tt[i];
            }
            else{
                continue;
            }
        }
        return c;
    }
    else{
        Coordinate c(0,0);
        return c;
    }   
}

/*
@brief: Compute distance to start of each point between start and end and assign it to _dist;
@param[in]ï¼š start is the start point, end is the end point.
@details: initial value of _dist of each point is -1;
*/
void Graph::assignAllDist(Coordinate start,Coordinate end){
    assignDist(start,0);
    std::vector<Coordinate> tt={};
    std::vector<Coordinate> nt={};
    tt.push_back(start);
    setGen(start,0);
    while(tt.size()!=0){
        nt=findNext(tt);//find next generation and set their number of _gen
        std::vector<Coordinate> ctt=tt;//copy of tt
        while(ctt.size()!=0){
            Coordinate c=minDist(ctt);
            c.deleteFrom(ctt);
            int dc=getDist(c);
            std::vector<Coordinate> c_ar=getAround(c);
            if(c_ar.size()!=0){
                for(std::vector<Coordinate>::iterator it=c_ar.begin(); it!=c_ar.end();++it){
                    if((*it).checkInVec(nt)){
                        if(!(*it).checkInVec(ctt)&& getDist(*it)==-1){
                            ctt.push_back(*it);
                        }
                        int dd=c.connectDist(*it);
                        if(getDist(*it)==-1|| getDist(*it)>dd+dc){
                            assignDist(*it,dd+dc);
                        }
                    }
                }
            }
        }
        tt=nt;
        if(getGen(end)!=-1 && getGen(tt[0])>getGen(end)){
            break;
        }
    }
    return;
}

/*
@breif: print the distance tabel.
*/
void Graph::printAlldist(){
    for(int i=0; i<_xmax;++i){
        for(int j=0; j<_ymax; ++j){
            Coordinate tmp(i,j);
            printf("(%d,%d)%d   ",i,j,getDist(tmp));
        }
        printf("\n");
    }
}

/*
details: Given the distance table, we need to search the path from start to end reversly.
*/
std::vector<Coordinate> Graph::reverseSearch(Coordinate start,Coordinate end){
    std::vector<Coordinate> path;
    if(getDist(end)==-1){
        return path;
    }
    path.push_back(end);
    Coordinate medial(end);
    while(!start.checkEq(medial)){
        std::vector<Coordinate> ar_med=getAround(medial);
        medial=minDist(ar_med);
        path.insert(path.begin(),medial);
        if(getDist(medial)==-1){
            break;
        }
    }
    return path;
}

/*
@fn: PrintGraph
@brief: print the structure of the graph
@details: using to check the graph generated by a matrix
*/
void Graph::printGraph(){
    for (int i=0; i<_xmax; ++i){
        for(int j=0; j<_ymax;++j){
            if(_nodes[i][j]->_color==kWhite){
                printf("color=white (%d,%d)->>>",i,j);
            }
            if(_nodes[i][j]->_color==kBlack){
                printf("color=black (%d,%d)->>>",i,j);
            }
            Coordinate c(i,j);
            std::vector<Coordinate> ar=getAround(c);
            printPath(ar);
        }
    }
}
